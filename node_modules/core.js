/*
  config
    actions - object of action functions with signature (ctx, data)
    userInitFunc - function that returns userData object for a new user
    globalInitFunc - function that returns new global state object
    userUpdateFunc - per user logic update function with signature (ctx, deltaTime)
    globalUpdateFunc - global logic update function with sinature (globalState, activeUsers, deltaTime)
    renderFunc - function that formats the data to be sent for each client with signature (userData, globalState)
    updateInterval - logic update interval in milliseconds, defaults to 50

  ctx
    self - reference to the current players userData
    activeUsers - all active users
    globalState - current global state
*/

module.exports.start = function(io, config) {
    var users = new Map();
    var globalState = config.globalInitFunc ? config.globalInitFunc() : {};

    var activeUsers = new Map();
    var connections = new Set();

    io.on("connection", function(socket) {
        var connCtx = {
            user: null,
            socket: socket
        }

        socket.on("disconnect", function() {
            if (connCtx.user != null) {
                connections.delete(connCtx);
                console.log("user disconnected: " + connCtx
                    .user.name);
            }
        });

        socket.on("login", function(data) {
            var user = users.get(data.code);
            if (!user) {
                socket.emit("loginError", {
                    message: "invalid user code"
                });
                return;
            }
            if (user.name == null) {
                if (!validateName(data.name)) {
                    socket.emit("loginError", {
                        message: "illegal user name"
                    });
                    return;
                }
                user.name = data.name;
                activeUsers.set(user.name, user.data);

            } else if (user.name != data.name) {
                socket.emit("loginError", {
                    message: "invalid user name"
                });
                return;
            }
            connCtx.user = user;
            connections.add(connCtx);

            socket.emit("loginSuccess");
            console.log("user logged in: " + connCtx.user.name);
        });

        // bind all actions
        if (config.actions) {
            Object.keys(config.actions).forEach(function(path) {
                if (path == "login" || path == "disconnect") {
                    console.log(
                        "cannot bind to reserved path: " +
                        path);
                    return
                }
                var action = config.actions[path];
                socket.on(path, function(data) {
                    if (connCtx.user != null) {
                        action(connCtx.user.ctx,
                            data);
                    }
                });
            });
        }
    });

    setInterval(function() {
        var deltaTime = (config.updateInterval || 50) / 1000;

        if (config.userUpdateFunc) {
            users.forEach(function(user) {
                if (user.name != null) {
                    config.userUpdateFunc(user.ctx,
                        deltaTime);
                }
            });
        }
        if (config.globalUpdateFunc) {
            config.globalUpdateFunc(globalState, activeUsers,
                deltaTime);
        }
        if (config.renderFunc) {
            connections.forEach(function(connCtx) {
                connCtx.socket.emit("renderUpdate", config.renderFunc(
                    connCtx.user.data, globalState))
            });
        }
    }, config.updateInterval || 50)

    function createUser(code, name) {
        if (users.has(code) || (name && !validateName(name))) {
            return false;
        }
        var userData = config.userInitFunc ? config.userInitFunc() : {}
        var user = {
            name: name || null,
            data: userData,
            ctx: {
                self: userData,
                activeUsers: activeUsers,
                globalState: globalState
            }
        };
        users.set(code, user);

        if (user.name != null) {
            activeUsers.set(user.name, user.data);
        }
        return true;
    }

    return {
        createUser: createUser,
    };
}

function validateName(name) {
    return typeof name === "string"; // TODO: add proper sanity checking
}
